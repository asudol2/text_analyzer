#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <regex>
#include <tuple>

#include "paradigms.h"
#include "paradigm_functions.h"




// Count all the words in text
void ParadigmWords::find_pattern() {
    std::regex word_regex("(\\w+)");
    auto words_begin =
        std::sregex_iterator(text->begin(), text->end(), word_regex);
    auto words_end = std::sregex_iterator();
    result = std::distance(words_begin, words_end);
};


// Find and count words longer than given length
void ParadigmLongerThan::find_pattern() {
    std::regex word_regex("(\\w+)");
    auto words_begin =
        std::sregex_iterator(text->begin(), text->end(), word_regex);
    auto words_end = std::sregex_iterator();
    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {
        std::smatch match = *i;
        std::string match_str = match.str();
        if (match_str.size() > length) {
            patterned_text_ += match_str += " ";
            result++;
        };
    };
};


// Find and count words shorter than given length
void ParadigmShorterThan::find_pattern() {
    std::regex word_regex("(\\w+)");
    auto words_begin =
        std::sregex_iterator(text->begin(), text->end(), word_regex);
    auto words_end = std::sregex_iterator();
    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {
        std::smatch match = *i;
        std::string match_str = match.str();
        if (match_str.size() < length) {
            patterned_text_ += match_str += " ";
            result++;
        };
    };
};


// Find and count words equal given length
void ParadigmEqualLength::find_pattern() {
    std::regex word_regex("(\\w+)");
    auto words_begin =
        std::sregex_iterator(text->begin(), text->end(), word_regex);
    auto words_end = std::sregex_iterator();
    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {
        std::smatch match = *i;
        std::string match_str = match.str();
        if (match_str.size() == length) {
            patterned_text_ += match_str += " ";
            result++;
        };
    };
};


void ParadigmStartsWithSequence::find_pattern() {
    if (seq_.empty()) { return; }

    std::string pattern = "\\b(";
    pattern += seq_;
    pattern += ")([A-Za-z]*)";
    std::regex word_regex(pattern);
    auto words_begin =
        std::sregex_iterator(text->begin(), text->end(), word_regex);
    auto words_end = std::sregex_iterator();
    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {
        std::smatch match = *i;
        std::string match_str = match.str();
        patterned_text_ += match_str += " ";
        result++;
    };
};


void ParadigmEndsOnSequence::find_pattern() {
    if (seq_.empty()) { return; }

    std::string pattern = "([^ ]*)(";
    pattern += seq_;
    pattern += ")([ ])";
    std::regex word_regex(pattern);
    auto words_begin =
        std::sregex_iterator(text->begin(), text->end(), word_regex);
    auto words_end = std::sregex_iterator();
    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {
        std::smatch match = *i;
        std::string match_str = match.str();
        patterned_text_ += match_str += " ";
        result++;
    };
};


void ParadigmContainSequence::find_pattern() {
    if (seq_.empty() || seq_ == " ") { return; }  //to correct for more spaces

    std::string pattern = "([^ ]*)(";
    pattern += seq_;
    pattern += ")([A-Za-z]*)";
    std::regex word_regex(pattern);
    auto words_begin =
        std::sregex_iterator(text->begin(), text->end(), word_regex);
    auto words_end = std::sregex_iterator();
    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {
        std::smatch match = *i;
        std::string match_str = match.str();
        patterned_text_ += match_str += " ";
        result++;
    };
};


void ParadigmCustom::find_pattern() {
    if (regex_.empty()) { return; }

    std::regex word_regex(regex_);
    auto words_begin =
        std::sregex_iterator(text->begin(), text->end(), word_regex);
    auto words_end = std::sregex_iterator();
    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {
        std::smatch match = *i;
        std::string match_str = match.str();
        patterned_text_ += match_str += " ";
        result++;
    };
};


//return number of words being in intersection of paradigms given in vector
int ParadigmIntersection(std::string text, std::vector< std::pair<char, std::string> > paradigms) {
    std::string to_modify = get_intersection(text, paradigms);
    ParadigmWords p(to_modify);
    return p.number_of_words();
};


//return number of words being in union of paradigms given in vector
int ParadigmUnion(std::string text, std::vector< std::pair<char, std::string> > paradigms) {

    std::string union_string = get_union(text, paradigms);
    ParadigmWords p(union_string);
    return p.number_of_words();
};




